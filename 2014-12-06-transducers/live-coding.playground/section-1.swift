import Foundation






































































extension Int {
  func square () -> Int {
    return self * self
  }
  func incr () -> Int {
    return self + 1
  }
}






































































func square (x: Int) -> Int {
  return x * x
}
func incr (x: Int) -> Int {
  return x + 1
}





































































//infix operator |> {associativity left}
//func |> <A, B> (x: A, f: A -> B) -> B {
//}


//func |> <A, B, C> (f: A -> B, g: B -> C) -> (A -> C) {
//}






































































//func isPrime (p: Int) -> Bool {
//  if p <= 1 { return false }
//  if p <= 3 { return true }
//  for i in 2...Int(sqrtf(Float(p))) {
//    if p % i == 0 { return false }
//  }
//  return true
//}







































































func map_from_reduce <A, B> (f: A -> B) -> [A] -> [B] {
  return { xs in
    return reduce(xs, []) { accum, x in
      return accum + [f(x)]
    }
  }
}

func filter_from_reduce <A> (p: A -> Bool) -> [A] -> [A] {
  return { xs in
    return reduce(xs, []) { accum, x in
      return p(x) ? accum + [x] : accum
    }
  }
}

func take_from_reduce <A> (n: Int) -> [A] -> [A] {
  return { xs in
    return reduce(xs, []) { accum, x in
      return accum.count < n ? accum + [x] : accum
    }
  }
}

func flatten_from_reduce <A> (xss: [[A]]) -> [A] {
  return reduce(xss, []) { accum, xs in
    return accum + xs
  }
}

































































//func squaringTransducer <C> (reducer: (C, Int) -> C) -> ((C, Int) -> C) {
//}

































































//func mapping <A, B, C> (f: A -> B) -> (((C, B) -> C) -> ((C, A) -> C)) {
//}






































































//func filtering <A, C> (p: A -> Bool) -> ((C, A) -> C) -> (C, A) -> C {
//}






































































//func append <A> (xs: [A], x: A) -> [A] {
//  return xs + [x]
//}






































